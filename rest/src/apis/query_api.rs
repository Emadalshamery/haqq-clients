/*
 * cosmos/app/v1alpha1/module.proto
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Account0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_address_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountAddressByIdError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`address_bytes_to_string`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressBytesToStringError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`address_string_to_bytes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressStringToBytesError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`all_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AllBalancesError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`all_evidence`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AllEvidenceError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`allowance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AllowanceError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`allowances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AllowancesError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`allowances_by_granter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AllowancesByGranterError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`annual_provisions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnnualProvisionsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applied_plan`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppliedPlanError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authority`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthorityError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalanceError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`balance_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Balance0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`balance_1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Balance1Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalancesError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`base_fee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BaseFeeError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`base_fee_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BaseFee0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bech32_prefix`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bech32PrefixError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`block_gas`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlockGasError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`class`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClassError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`classes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClassesError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`community_pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CommunityPoolError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cosmos_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CosmosAccountError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`current_epoch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CurrentEpochError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`current_plan`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CurrentPlanError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegationError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegation_rewards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegationRewardsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegation_total_rewards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegationTotalRewardsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegator_delegations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegatorDelegationsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegator_unbonding_delegations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegatorUnbondingDelegationsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegator_validator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegatorValidatorError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegator_validators`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegatorValidatorsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegator_validators_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegatorValidators0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegator_withdraw_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegatorWithdrawAddressError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`denom_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DenomMetadataError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`denom_owners`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DenomOwnersError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`denoms_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DenomsMetadataError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`deposit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DepositError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`deposit_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Deposit0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`deposits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DepositsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`deposits_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Deposits0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`epoch_infos`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EpochInfosError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`era`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EraError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`era_closing_supply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EraClosingSupplyError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`estimate_gas`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EstimateGasError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`eth_call`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EthCallError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`evidence`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EvidenceError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`grantee_grants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GranteeGrantsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`granter_grants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GranterGrantsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`grants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GrantsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupInfoError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_members`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupMembersError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_policies_by_admin`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupPoliciesByAdminError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_policies_by_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupPoliciesByGroupError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_policy_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupPolicyInfoError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_by_admin`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsByAdminError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_by_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsByMemberError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`historical_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HistoricalInfoError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`inflation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InflationError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`inflation_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InflationRateError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`max_supply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MaxSupplyError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`module_account_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModuleAccountByNameError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`module_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModuleAccountsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`module_versions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModuleVersionsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`n_ft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NFtError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`n_fts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NFtsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`owner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OwnerError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParamsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params1Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_10`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params10Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_11`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params11Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params2Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params3Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_4`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params4Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_5`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params5Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_6`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params6Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_7`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params7Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_8`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params8Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`params_9`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Params9Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoolError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proposal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProposalError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proposal_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Proposal0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proposal_1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Proposal1Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proposals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProposalsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proposals_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Proposals0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proposals_by_group_policy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProposalsByGroupPolicyError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`redelegations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RedelegationsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`signing_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SigningInfoError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`signing_infos`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SigningInfosError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spendable_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpendableBalancesError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StorageError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subspaces`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubspacesError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`supply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SupplyError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`supply_of`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SupplyOfError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tally_result`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TallyResultError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tally_result_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TallyResult0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tally_result_1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TallyResult1Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`token_pair`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TokenPairError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`token_pairs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TokenPairsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`total_locked`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TotalLockedError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`total_supply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TotalSupplyError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trace_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TraceBlockError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trace_tx`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TraceTxError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unbonding_delegation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnbondingDelegationError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upgraded_consensus_state`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpgradedConsensusStateError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatorError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validator_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatorAccountError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validator_commission`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatorCommissionError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validator_delegations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatorDelegationsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validator_distribution_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatorDistributionInfoError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validator_outstanding_rewards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatorOutstandingRewardsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validator_slashes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatorSlashesError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validator_unbonding_delegations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatorUnbondingDelegationsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validators`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatorsError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vote`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VoteError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vote_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Vote0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vote_by_proposal_voter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VoteByProposalVoterError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`votes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`votes_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Votes0Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`votes_by_proposal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesByProposalError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`votes_by_voter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesByVoterError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}


pub async fn account(configuration: &configuration::Configuration, address: &str) -> Result<crate::models::CosmosPeriodAuthPeriodV1beta1PeriodQueryAccountResponse, Error<AccountError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/accounts/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn account_0(configuration: &configuration::Configuration, address: &str) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryAccountResponse, Error<Account0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/account/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Account0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46.2
pub async fn account_address_by_id(configuration: &configuration::Configuration, id: &str) -> Result<crate::models::CosmosPeriodAuthPeriodV1beta1PeriodQueryAccountAddressByIdResponse, Error<AccountAddressByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/address_by_id/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AccountAddressByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.43
pub async fn accounts(configuration: &configuration::Configuration, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodAuthPeriodV1beta1PeriodQueryAccountsResponse, Error<AccountsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/accounts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AccountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn address_bytes_to_string(configuration: &configuration::Configuration, address_bytes: String) -> Result<crate::models::CosmosPeriodAuthPeriodV1beta1PeriodAddressBytesToStringResponse, Error<AddressBytesToStringError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/bech32/{addressBytes}", local_var_configuration.base_path, addressBytes=address_bytes);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddressBytesToStringError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn address_string_to_bytes(configuration: &configuration::Configuration, address_string: &str) -> Result<crate::models::CosmosPeriodAuthPeriodV1beta1PeriodAddressStringToBytesResponse, Error<AddressStringToBytesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/bech32/{addressString}", local_var_configuration.base_path, addressString=crate::apis::urlencode(address_string));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddressStringToBytesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn all_balances(configuration: &configuration::Configuration, address: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodBankPeriodV1beta1PeriodQueryAllBalancesResponse, Error<AllBalancesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/balances/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AllBalancesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn all_evidence(configuration: &configuration::Configuration, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodEvidencePeriodV1beta1PeriodQueryAllEvidenceResponse, Error<AllEvidenceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/evidence/v1beta1/evidence", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AllEvidenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn allowance(configuration: &configuration::Configuration, granter: &str, grantee: &str) -> Result<crate::models::CosmosPeriodFeegrantPeriodV1beta1PeriodQueryAllowanceResponse, Error<AllowanceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}", local_var_configuration.base_path, granter=crate::apis::urlencode(granter), grantee=crate::apis::urlencode(grantee));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AllowanceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn allowances(configuration: &configuration::Configuration, grantee: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodFeegrantPeriodV1beta1PeriodQueryAllowancesResponse, Error<AllowancesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/feegrant/v1beta1/allowances/{grantee}", local_var_configuration.base_path, grantee=crate::apis::urlencode(grantee));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AllowancesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn allowances_by_granter(configuration: &configuration::Configuration, granter: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodFeegrantPeriodV1beta1PeriodQueryAllowancesByGranterResponse, Error<AllowancesByGranterError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/feegrant/v1beta1/issued/{granter}", local_var_configuration.base_path, granter=crate::apis::urlencode(granter));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AllowancesByGranterError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn annual_provisions(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodMintPeriodV1beta1PeriodQueryAnnualProvisionsResponse, Error<AnnualProvisionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/mint/v1beta1/annual_provisions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AnnualProvisionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applied_plan(configuration: &configuration::Configuration, name: &str) -> Result<crate::models::CosmosPeriodUpgradePeriodV1beta1PeriodQueryAppliedPlanResponse, Error<AppliedPlanError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/upgrade/v1beta1/applied_plan/{name}", local_var_configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AppliedPlanError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn authority(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodUpgradePeriodV1beta1PeriodQueryAuthorityResponse, Error<AuthorityError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/upgrade/v1beta1/authority", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthorityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn balance(configuration: &configuration::Configuration, address: &str, denom: Option<&str>) -> Result<crate::models::CosmosPeriodBankPeriodV1beta1PeriodQueryBalanceResponse, Error<BalanceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/balances/{address}/by_denom", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = denom {
        local_var_req_builder = local_var_req_builder.query(&[("denom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BalanceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn balance_0(configuration: &configuration::Configuration, owner: &str, class_id: &str) -> Result<crate::models::CosmosPeriodNftPeriodV1beta1PeriodQueryBalanceResponse, Error<Balance0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/nft/v1beta1/balance/{owner}/{classId}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), classId=crate::apis::urlencode(class_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Balance0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn balance_1(configuration: &configuration::Configuration, address: &str) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryBalanceResponse, Error<Balance1Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/balances/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Balance1Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn balances(configuration: &configuration::Configuration, address: &str) -> Result<crate::models::HaqqPeriodVestingPeriodV1PeriodQueryBalancesResponse, Error<BalancesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqq/vesting/v1/balances/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BalancesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn base_fee(configuration: &configuration::Configuration, ) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryBaseFeeResponse, Error<BaseFeeError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/base_fee", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BaseFeeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn base_fee_0(configuration: &configuration::Configuration, ) -> Result<crate::models::EthermintPeriodFeemarketPeriodV1PeriodQueryBaseFeeResponse, Error<BaseFee0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/feemarket/v1/base_fee", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BaseFee0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn bech32_prefix(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodAuthPeriodV1beta1PeriodBech32PrefixResponse, Error<Bech32PrefixError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/bech32", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Bech32PrefixError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn block_gas(configuration: &configuration::Configuration, ) -> Result<crate::models::EthermintPeriodFeemarketPeriodV1PeriodQueryBlockGasResponse, Error<BlockGasError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/feemarket/v1/block_gas", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlockGasError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn class(configuration: &configuration::Configuration, class_id: &str) -> Result<crate::models::CosmosPeriodNftPeriodV1beta1PeriodQueryClassResponse, Error<ClassError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/nft/v1beta1/classes/{classId}", local_var_configuration.base_path, classId=crate::apis::urlencode(class_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ClassError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn classes(configuration: &configuration::Configuration, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodNftPeriodV1beta1PeriodQueryClassesResponse, Error<ClassesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/nft/v1beta1/classes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ClassesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn code(configuration: &configuration::Configuration, address: &str) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryCodeResponse, Error<CodeError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/codes/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn community_pool(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryCommunityPoolResponse, Error<CommunityPoolError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/community_pool", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CommunityPoolError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn cosmos_account(configuration: &configuration::Configuration, address: &str) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryCosmosAccountResponse, Error<CosmosAccountError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/cosmos_account/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CosmosAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn current_epoch(configuration: &configuration::Configuration, identifier: Option<&str>) -> Result<crate::models::EvmosPeriodEpochsPeriodV1PeriodQueryCurrentEpochResponse, Error<CurrentEpochError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/epochs/v1/current_epoch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identifier {
        local_var_req_builder = local_var_req_builder.query(&[("identifier", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CurrentEpochError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn current_plan(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodUpgradePeriodV1beta1PeriodQueryCurrentPlanResponse, Error<CurrentPlanError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/upgrade/v1beta1/current_plan", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CurrentPlanError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegation(configuration: &configuration::Configuration, validator_addr: &str, delegator_addr: &str) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryDelegationResponse, Error<DelegationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations/{delegatorAddr}", local_var_configuration.base_path, validatorAddr=crate::apis::urlencode(validator_addr), delegatorAddr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DelegationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegation_rewards(configuration: &configuration::Configuration, delegator_address: &str, validator_address: &str) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryDelegationRewardsResponse, Error<DelegationRewardsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/rewards/{validatorAddress}", local_var_configuration.base_path, delegatorAddress=crate::apis::urlencode(delegator_address), validatorAddress=crate::apis::urlencode(validator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DelegationRewardsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegation_total_rewards(configuration: &configuration::Configuration, delegator_address: &str) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryDelegationTotalRewardsResponse, Error<DelegationTotalRewardsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/rewards", local_var_configuration.base_path, delegatorAddress=crate::apis::urlencode(delegator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DelegationTotalRewardsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_delegations(configuration: &configuration::Configuration, delegator_addr: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryDelegatorDelegationsResponse, Error<DelegatorDelegationsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegations/{delegatorAddr}", local_var_configuration.base_path, delegatorAddr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DelegatorDelegationsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_unbonding_delegations(configuration: &configuration::Configuration, delegator_addr: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryDelegatorUnbondingDelegationsResponse, Error<DelegatorUnbondingDelegationsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegators/{delegatorAddr}/unbonding_delegations", local_var_configuration.base_path, delegatorAddr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DelegatorUnbondingDelegationsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_validator(configuration: &configuration::Configuration, delegator_addr: &str, validator_addr: &str) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryDelegatorValidatorResponse, Error<DelegatorValidatorError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegators/{delegatorAddr}/validators/{validatorAddr}", local_var_configuration.base_path, delegatorAddr=crate::apis::urlencode(delegator_addr), validatorAddr=crate::apis::urlencode(validator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DelegatorValidatorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_validators(configuration: &configuration::Configuration, delegator_address: &str) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryDelegatorValidatorsResponse, Error<DelegatorValidatorsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/validators", local_var_configuration.base_path, delegatorAddress=crate::apis::urlencode(delegator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DelegatorValidatorsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_validators_0(configuration: &configuration::Configuration, delegator_addr: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryDelegatorValidatorsResponse, Error<DelegatorValidators0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegators/{delegatorAddr}/validators", local_var_configuration.base_path, delegatorAddr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DelegatorValidators0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delegator_withdraw_address(configuration: &configuration::Configuration, delegator_address: &str) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryDelegatorWithdrawAddressResponse, Error<DelegatorWithdrawAddressError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/delegators/{delegatorAddress}/withdraw_address", local_var_configuration.base_path, delegatorAddress=crate::apis::urlencode(delegator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DelegatorWithdrawAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn denom_metadata(configuration: &configuration::Configuration, denom: &str) -> Result<crate::models::CosmosPeriodBankPeriodV1beta1PeriodQueryDenomMetadataResponse, Error<DenomMetadataError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/denoms_metadata/{denom}", local_var_configuration.base_path, denom=crate::apis::urlencode(denom));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DenomMetadataError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn denom_owners(configuration: &configuration::Configuration, denom: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodBankPeriodV1beta1PeriodQueryDenomOwnersResponse, Error<DenomOwnersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/denom_owners/{denom}", local_var_configuration.base_path, denom=crate::apis::urlencode(denom));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DenomOwnersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn denoms_metadata(configuration: &configuration::Configuration, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodBankPeriodV1beta1PeriodQueryDenomsMetadataResponse, Error<DenomsMetadataError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/denoms_metadata", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DenomsMetadataError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn deposit(configuration: &configuration::Configuration, proposal_id: &str, depositor: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1PeriodQueryDepositResponse, Error<DepositError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1/proposals/{proposalId}/deposits/{depositor}", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id), depositor=crate::apis::urlencode(depositor));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DepositError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn deposit_0(configuration: &configuration::Configuration, proposal_id: &str, depositor: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1beta1PeriodQueryDepositResponse, Error<Deposit0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposalId}/deposits/{depositor}", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id), depositor=crate::apis::urlencode(depositor));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Deposit0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn deposits(configuration: &configuration::Configuration, proposal_id: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGovPeriodV1PeriodQueryDepositsResponse, Error<DepositsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1/proposals/{proposalId}/deposits", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DepositsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn deposits_0(configuration: &configuration::Configuration, proposal_id: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGovPeriodV1beta1PeriodQueryDepositsResponse, Error<Deposits0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposalId}/deposits", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Deposits0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn epoch_infos(configuration: &configuration::Configuration, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::EvmosPeriodEpochsPeriodV1PeriodQueryEpochsInfoResponse, Error<EpochInfosError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/epochs/v1/epochs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EpochInfosError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn era(configuration: &configuration::Configuration, ) -> Result<crate::models::HaqqPeriodCoinomicsPeriodV1PeriodQueryEraResponse, Error<EraError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqqd/coinomics/v1/era", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EraError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn era_closing_supply(configuration: &configuration::Configuration, ) -> Result<crate::models::HaqqPeriodCoinomicsPeriodV1PeriodQueryEraClosingSupplyResponse, Error<EraClosingSupplyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqqd/coinomics/v1/era_closing_supply", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EraClosingSupplyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn estimate_gas(configuration: &configuration::Configuration, args: Option<String>, gas_cap: Option<&str>, proposer_address: Option<String>, chain_id: Option<&str>) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodEstimateGasResponse, Error<EstimateGasError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/estimate_gas", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = args {
        local_var_req_builder = local_var_req_builder.query(&[("args", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = gas_cap {
        local_var_req_builder = local_var_req_builder.query(&[("gasCap", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proposer_address {
        local_var_req_builder = local_var_req_builder.query(&[("proposerAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = chain_id {
        local_var_req_builder = local_var_req_builder.query(&[("chainId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EstimateGasError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn eth_call(configuration: &configuration::Configuration, args: Option<String>, gas_cap: Option<&str>, proposer_address: Option<String>, chain_id: Option<&str>) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodMsgEthereumTxResponse, Error<EthCallError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/eth_call", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = args {
        local_var_req_builder = local_var_req_builder.query(&[("args", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = gas_cap {
        local_var_req_builder = local_var_req_builder.query(&[("gasCap", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proposer_address {
        local_var_req_builder = local_var_req_builder.query(&[("proposerAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = chain_id {
        local_var_req_builder = local_var_req_builder.query(&[("chainId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EthCallError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn evidence(configuration: &configuration::Configuration, evidence_hash: String) -> Result<crate::models::CosmosPeriodEvidencePeriodV1beta1PeriodQueryEvidenceResponse, Error<EvidenceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/evidence/v1beta1/evidence/{evidenceHash}", local_var_configuration.base_path, evidenceHash=evidence_hash);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EvidenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn grantee_grants(configuration: &configuration::Configuration, grantee: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodAuthzPeriodV1beta1PeriodQueryGranteeGrantsResponse, Error<GranteeGrantsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/authz/v1beta1/grants/grantee/{grantee}", local_var_configuration.base_path, grantee=crate::apis::urlencode(grantee));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GranteeGrantsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn granter_grants(configuration: &configuration::Configuration, granter: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodAuthzPeriodV1beta1PeriodQueryGranterGrantsResponse, Error<GranterGrantsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/authz/v1beta1/grants/granter/{granter}", local_var_configuration.base_path, granter=crate::apis::urlencode(granter));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GranterGrantsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn grants(configuration: &configuration::Configuration, granter: Option<&str>, grantee: Option<&str>, msg_type_url: Option<&str>, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodAuthzPeriodV1beta1PeriodQueryGrantsResponse, Error<GrantsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/authz/v1beta1/grants", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = granter {
        local_var_req_builder = local_var_req_builder.query(&[("granter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = grantee {
        local_var_req_builder = local_var_req_builder.query(&[("grantee", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = msg_type_url {
        local_var_req_builder = local_var_req_builder.query(&[("msgTypeUrl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GrantsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn group_info(configuration: &configuration::Configuration, group_id: &str) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryGroupInfoResponse, Error<GroupInfoError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/group_info/{groupId}", local_var_configuration.base_path, groupId=crate::apis::urlencode(group_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn group_members(configuration: &configuration::Configuration, group_id: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryGroupMembersResponse, Error<GroupMembersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/group_members/{groupId}", local_var_configuration.base_path, groupId=crate::apis::urlencode(group_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupMembersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn group_policies_by_admin(configuration: &configuration::Configuration, admin: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryGroupPoliciesByAdminResponse, Error<GroupPoliciesByAdminError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/group_policies_by_admin/{admin}", local_var_configuration.base_path, admin=crate::apis::urlencode(admin));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupPoliciesByAdminError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn group_policies_by_group(configuration: &configuration::Configuration, group_id: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryGroupPoliciesByGroupResponse, Error<GroupPoliciesByGroupError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/group_policies_by_group/{groupId}", local_var_configuration.base_path, groupId=crate::apis::urlencode(group_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupPoliciesByGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn group_policy_info(configuration: &configuration::Configuration, address: &str) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryGroupPolicyInfoResponse, Error<GroupPolicyInfoError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/group_policy_info/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupPolicyInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.47.1
pub async fn groups(configuration: &configuration::Configuration, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryGroupsResponse, Error<GroupsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/groups", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn groups_by_admin(configuration: &configuration::Configuration, admin: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryGroupsByAdminResponse, Error<GroupsByAdminError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/groups_by_admin/{admin}", local_var_configuration.base_path, admin=crate::apis::urlencode(admin));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupsByAdminError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn groups_by_member(configuration: &configuration::Configuration, address: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryGroupsByMemberResponse, Error<GroupsByMemberError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/groups_by_member/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupsByMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn historical_info(configuration: &configuration::Configuration, height: &str) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryHistoricalInfoResponse, Error<HistoricalInfoError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/historical_info/{height}", local_var_configuration.base_path, height=crate::apis::urlencode(height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HistoricalInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn inflation(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodMintPeriodV1beta1PeriodQueryInflationResponse, Error<InflationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/mint/v1beta1/inflation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<InflationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn inflation_rate(configuration: &configuration::Configuration, ) -> Result<crate::models::HaqqPeriodCoinomicsPeriodV1PeriodQueryInflationRateResponse, Error<InflationRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqq/coinomics/v1/inflation_rate", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<InflationRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn max_supply(configuration: &configuration::Configuration, ) -> Result<crate::models::HaqqPeriodCoinomicsPeriodV1PeriodQueryMaxSupplyResponse, Error<MaxSupplyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqqd/coinomics/v1/max_supply", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MaxSupplyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn module_account_by_name(configuration: &configuration::Configuration, name: &str) -> Result<crate::models::CosmosPeriodAuthPeriodV1beta1PeriodQueryModuleAccountByNameResponse, Error<ModuleAccountByNameError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/module_accounts/{name}", local_var_configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModuleAccountByNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn module_accounts(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodAuthPeriodV1beta1PeriodQueryModuleAccountsResponse, Error<ModuleAccountsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/module_accounts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModuleAccountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.43
pub async fn module_versions(configuration: &configuration::Configuration, module_name: Option<&str>) -> Result<crate::models::CosmosPeriodUpgradePeriodV1beta1PeriodQueryModuleVersionsResponse, Error<ModuleVersionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/upgrade/v1beta1/module_versions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = module_name {
        local_var_req_builder = local_var_req_builder.query(&[("moduleName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ModuleVersionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn n_ft(configuration: &configuration::Configuration, class_id: &str, id: &str) -> Result<crate::models::CosmosPeriodNftPeriodV1beta1PeriodQueryNftResponse, Error<NFtError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/nft/v1beta1/nfts/{classId}/{id}", local_var_configuration.base_path, classId=crate::apis::urlencode(class_id), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NFtError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn n_fts(configuration: &configuration::Configuration, class_id: Option<&str>, owner: Option<&str>, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodNftPeriodV1beta1PeriodQueryNftsResponse, Error<NFtsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/nft/v1beta1/nfts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = class_id {
        local_var_req_builder = local_var_req_builder.query(&[("classId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = owner {
        local_var_req_builder = local_var_req_builder.query(&[("owner", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NFtsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn owner(configuration: &configuration::Configuration, class_id: &str, id: &str) -> Result<crate::models::CosmosPeriodNftPeriodV1beta1PeriodQueryOwnerResponse, Error<OwnerError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/nft/v1beta1/owner/{classId}/{id}", local_var_configuration.base_path, classId=crate::apis::urlencode(class_id), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OwnerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodAuthPeriodV1beta1PeriodQueryParamsResponse, Error<ParamsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/auth/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ParamsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_0(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodBankPeriodV1beta1PeriodQueryParamsResponse, Error<Params0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_1(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryParamsResponse, Error<Params1Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params1Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_10(configuration: &configuration::Configuration, ) -> Result<crate::models::EthermintPeriodFeemarketPeriodV1PeriodQueryParamsResponse, Error<Params10Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/feemarket/v1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params10Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_11(configuration: &configuration::Configuration, ) -> Result<crate::models::HaqqPeriodCoinomicsPeriodV1PeriodQueryParamsResponse, Error<Params11Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqq/coinomics/v1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params11Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_2(configuration: &configuration::Configuration, params_type: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1PeriodQueryParamsResponse, Error<Params2Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1/params/{paramsType}", local_var_configuration.base_path, paramsType=crate::apis::urlencode(params_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params2Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_3(configuration: &configuration::Configuration, params_type: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1beta1PeriodQueryParamsResponse, Error<Params3Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/params/{paramsType}", local_var_configuration.base_path, paramsType=crate::apis::urlencode(params_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params3Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_4(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodMintPeriodV1beta1PeriodQueryParamsResponse, Error<Params4Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/mint/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params4Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_5(configuration: &configuration::Configuration, subspace: Option<&str>, key: Option<&str>) -> Result<crate::models::CosmosPeriodParamsPeriodV1beta1PeriodQueryParamsResponse, Error<Params5Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/params/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = subspace {
        local_var_req_builder = local_var_req_builder.query(&[("subspace", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params5Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_6(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodSlashingPeriodV1beta1PeriodQueryParamsResponse, Error<Params6Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/slashing/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params6Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_7(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryParamsResponse, Error<Params7Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params7Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_8(configuration: &configuration::Configuration, ) -> Result<crate::models::EvmosPeriodErc20PeriodV1PeriodQueryParamsResponse, Error<Params8Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/erc20/v1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params8Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn params_9(configuration: &configuration::Configuration, ) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryParamsResponse, Error<Params9Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Params9Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn pool(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryPoolResponse, Error<PoolError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/pool", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PoolError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn proposal(configuration: &configuration::Configuration, proposal_id: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1PeriodQueryProposalResponse, Error<ProposalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1/proposals/{proposalId}", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProposalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn proposal_0(configuration: &configuration::Configuration, proposal_id: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1beta1PeriodQueryProposalResponse, Error<Proposal0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposalId}", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Proposal0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn proposal_1(configuration: &configuration::Configuration, proposal_id: &str) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryProposalResponse, Error<Proposal1Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/proposal/{proposalId}", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Proposal1Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn proposals(configuration: &configuration::Configuration, proposal_status: Option<&str>, voter: Option<&str>, depositor: Option<&str>, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGovPeriodV1PeriodQueryProposalsResponse, Error<ProposalsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1/proposals", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = proposal_status {
        local_var_req_builder = local_var_req_builder.query(&[("proposalStatus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voter {
        local_var_req_builder = local_var_req_builder.query(&[("voter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = depositor {
        local_var_req_builder = local_var_req_builder.query(&[("depositor", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProposalsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn proposals_0(configuration: &configuration::Configuration, proposal_status: Option<&str>, voter: Option<&str>, depositor: Option<&str>, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGovPeriodV1beta1PeriodQueryProposalsResponse, Error<Proposals0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = proposal_status {
        local_var_req_builder = local_var_req_builder.query(&[("proposalStatus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voter {
        local_var_req_builder = local_var_req_builder.query(&[("voter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = depositor {
        local_var_req_builder = local_var_req_builder.query(&[("depositor", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Proposals0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn proposals_by_group_policy(configuration: &configuration::Configuration, address: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryProposalsByGroupPolicyResponse, Error<ProposalsByGroupPolicyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/proposals_by_group_policy/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProposalsByGroupPolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn redelegations(configuration: &configuration::Configuration, delegator_addr: &str, src_validator_addr: Option<&str>, dst_validator_addr: Option<&str>, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryRedelegationsResponse, Error<RedelegationsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/delegators/{delegatorAddr}/redelegations", local_var_configuration.base_path, delegatorAddr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = src_validator_addr {
        local_var_req_builder = local_var_req_builder.query(&[("srcValidatorAddr", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dst_validator_addr {
        local_var_req_builder = local_var_req_builder.query(&[("dstValidatorAddr", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RedelegationsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn signing_info(configuration: &configuration::Configuration, cons_address: &str) -> Result<crate::models::CosmosPeriodSlashingPeriodV1beta1PeriodQuerySigningInfoResponse, Error<SigningInfoError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/slashing/v1beta1/signing_infos/{consAddress}", local_var_configuration.base_path, consAddress=crate::apis::urlencode(cons_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SigningInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn signing_infos(configuration: &configuration::Configuration, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodSlashingPeriodV1beta1PeriodQuerySigningInfosResponse, Error<SigningInfosError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/slashing/v1beta1/signing_infos", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SigningInfosError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn spendable_balances(configuration: &configuration::Configuration, address: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodBankPeriodV1beta1PeriodQuerySpendableBalancesResponse, Error<SpendableBalancesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/spendable_balances/{address}", local_var_configuration.base_path, address=crate::apis::urlencode(address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SpendableBalancesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn storage(configuration: &configuration::Configuration, address: &str, key: &str) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryStorageResponse, Error<StorageError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/storage/{address}/{key}", local_var_configuration.base_path, address=crate::apis::urlencode(address), key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StorageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Since: cosmos-sdk 0.46
pub async fn subspaces(configuration: &configuration::Configuration, ) -> Result<crate::models::CosmosPeriodParamsPeriodV1beta1PeriodQuerySubspacesResponse, Error<SubspacesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/params/v1beta1/subspaces", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SubspacesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn supply(configuration: &configuration::Configuration, class_id: &str) -> Result<crate::models::CosmosPeriodNftPeriodV1beta1PeriodQuerySupplyResponse, Error<SupplyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/nft/v1beta1/supply/{classId}", local_var_configuration.base_path, classId=crate::apis::urlencode(class_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SupplyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn supply_of(configuration: &configuration::Configuration, denom: Option<&str>) -> Result<crate::models::CosmosPeriodBankPeriodV1beta1PeriodQuerySupplyOfResponse, Error<SupplyOfError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/supply/by_denom", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = denom {
        local_var_req_builder = local_var_req_builder.query(&[("denom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SupplyOfError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn tally_result(configuration: &configuration::Configuration, proposal_id: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1PeriodQueryTallyResultResponse, Error<TallyResultError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1/proposals/{proposalId}/tally", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TallyResultError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn tally_result_0(configuration: &configuration::Configuration, proposal_id: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1beta1PeriodQueryTallyResultResponse, Error<TallyResult0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposalId}/tally", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TallyResult0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn tally_result_1(configuration: &configuration::Configuration, proposal_id: &str) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryTallyResultResponse, Error<TallyResult1Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/proposals/{proposalId}/tally", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TallyResult1Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn token_pair(configuration: &configuration::Configuration, token: &str) -> Result<crate::models::EvmosPeriodErc20PeriodV1PeriodQueryTokenPairResponse, Error<TokenPairError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/erc20/v1/token_pairs/{token}", local_var_configuration.base_path, token=crate::apis::urlencode(token));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TokenPairError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn token_pairs(configuration: &configuration::Configuration, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::EvmosPeriodErc20PeriodV1PeriodQueryTokenPairsResponse, Error<TokenPairsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/erc20/v1/token_pairs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TokenPairsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn total_locked(configuration: &configuration::Configuration, ) -> Result<crate::models::HaqqPeriodVestingPeriodV1PeriodQueryTotalLockedResponse, Error<TotalLockedError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqq/vesting/v1/total_locked", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TotalLockedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn total_supply(configuration: &configuration::Configuration, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodBankPeriodV1beta1PeriodQueryTotalSupplyResponse, Error<TotalSupplyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/bank/v1beta1/supply", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TotalSupplyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn trace_block(configuration: &configuration::Configuration, trace_config_period_tracer: Option<&str>, trace_config_period_timeout: Option<&str>, trace_config_period_reexec: Option<&str>, trace_config_period_disable_stack: Option<bool>, trace_config_period_disable_storage: Option<bool>, trace_config_period_debug: Option<bool>, trace_config_period_limit: Option<i32>, trace_config_period_overrides_period_homestead_block: Option<&str>, trace_config_period_overrides_period_dao_fork_block: Option<&str>, trace_config_period_overrides_period_dao_fork_support: Option<bool>, trace_config_period_overrides_period_eip150_block: Option<&str>, trace_config_period_overrides_period_eip150_hash: Option<&str>, trace_config_period_overrides_period_eip155_block: Option<&str>, trace_config_period_overrides_period_eip158_block: Option<&str>, trace_config_period_overrides_period_byzantium_block: Option<&str>, trace_config_period_overrides_period_constantinople_block: Option<&str>, trace_config_period_overrides_period_petersburg_block: Option<&str>, trace_config_period_overrides_period_istanbul_block: Option<&str>, trace_config_period_overrides_period_muir_glacier_block: Option<&str>, trace_config_period_overrides_period_berlin_block: Option<&str>, trace_config_period_overrides_period_london_block: Option<&str>, trace_config_period_overrides_period_arrow_glacier_block: Option<&str>, trace_config_period_overrides_period_gray_glacier_block: Option<&str>, trace_config_period_overrides_period_merge_netsplit_block: Option<&str>, trace_config_period_overrides_period_shanghai_block: Option<&str>, trace_config_period_overrides_period_cancun_block: Option<&str>, trace_config_period_enable_memory: Option<bool>, trace_config_period_enable_return_data: Option<bool>, trace_config_period_tracer_json_config: Option<&str>, block_number: Option<&str>, block_hash: Option<&str>, block_time: Option<String>, proposer_address: Option<String>, chain_id: Option<&str>) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryTraceBlockResponse, Error<TraceBlockError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/trace_block", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = trace_config_period_tracer {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.tracer", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_timeout {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.timeout", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_reexec {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.reexec", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_disable_stack {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.disableStack", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_disable_storage {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.disableStorage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_debug {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.debug", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_homestead_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.homesteadBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_dao_fork_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.daoForkBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_dao_fork_support {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.daoForkSupport", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_eip150_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.eip150Block", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_eip150_hash {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.eip150Hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_eip155_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.eip155Block", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_eip158_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.eip158Block", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_byzantium_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.byzantiumBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_constantinople_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.constantinopleBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_petersburg_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.petersburgBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_istanbul_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.istanbulBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_muir_glacier_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.muirGlacierBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_berlin_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.berlinBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_london_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.londonBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_arrow_glacier_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.arrowGlacierBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_gray_glacier_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.grayGlacierBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_merge_netsplit_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.mergeNetsplitBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_shanghai_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.shanghaiBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_cancun_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.cancunBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_enable_memory {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.enableMemory", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_enable_return_data {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.enableReturnData", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_tracer_json_config {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.tracerJsonConfig", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number {
        local_var_req_builder = local_var_req_builder.query(&[("blockNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_hash {
        local_var_req_builder = local_var_req_builder.query(&[("blockHash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_time {
        local_var_req_builder = local_var_req_builder.query(&[("blockTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proposer_address {
        local_var_req_builder = local_var_req_builder.query(&[("proposerAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = chain_id {
        local_var_req_builder = local_var_req_builder.query(&[("chainId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TraceBlockError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn trace_tx(configuration: &configuration::Configuration, msg_period_data_period_type_url: Option<&str>, msg_period_data_period_value: Option<String>, msg_period_size: Option<f64>, msg_period_hash: Option<&str>, msg_period_from: Option<&str>, trace_config_period_tracer: Option<&str>, trace_config_period_timeout: Option<&str>, trace_config_period_reexec: Option<&str>, trace_config_period_disable_stack: Option<bool>, trace_config_period_disable_storage: Option<bool>, trace_config_period_debug: Option<bool>, trace_config_period_limit: Option<i32>, trace_config_period_overrides_period_homestead_block: Option<&str>, trace_config_period_overrides_period_dao_fork_block: Option<&str>, trace_config_period_overrides_period_dao_fork_support: Option<bool>, trace_config_period_overrides_period_eip150_block: Option<&str>, trace_config_period_overrides_period_eip150_hash: Option<&str>, trace_config_period_overrides_period_eip155_block: Option<&str>, trace_config_period_overrides_period_eip158_block: Option<&str>, trace_config_period_overrides_period_byzantium_block: Option<&str>, trace_config_period_overrides_period_constantinople_block: Option<&str>, trace_config_period_overrides_period_petersburg_block: Option<&str>, trace_config_period_overrides_period_istanbul_block: Option<&str>, trace_config_period_overrides_period_muir_glacier_block: Option<&str>, trace_config_period_overrides_period_berlin_block: Option<&str>, trace_config_period_overrides_period_london_block: Option<&str>, trace_config_period_overrides_period_arrow_glacier_block: Option<&str>, trace_config_period_overrides_period_gray_glacier_block: Option<&str>, trace_config_period_overrides_period_merge_netsplit_block: Option<&str>, trace_config_period_overrides_period_shanghai_block: Option<&str>, trace_config_period_overrides_period_cancun_block: Option<&str>, trace_config_period_enable_memory: Option<bool>, trace_config_period_enable_return_data: Option<bool>, trace_config_period_tracer_json_config: Option<&str>, block_number: Option<&str>, block_hash: Option<&str>, block_time: Option<String>, proposer_address: Option<String>, chain_id: Option<&str>) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryTraceTxResponse, Error<TraceTxError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/trace_tx", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = msg_period_data_period_type_url {
        local_var_req_builder = local_var_req_builder.query(&[("msg.data.typeUrl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = msg_period_data_period_value {
        local_var_req_builder = local_var_req_builder.query(&[("msg.data.value", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = msg_period_size {
        local_var_req_builder = local_var_req_builder.query(&[("msg.size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = msg_period_hash {
        local_var_req_builder = local_var_req_builder.query(&[("msg.hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = msg_period_from {
        local_var_req_builder = local_var_req_builder.query(&[("msg.from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_tracer {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.tracer", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_timeout {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.timeout", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_reexec {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.reexec", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_disable_stack {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.disableStack", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_disable_storage {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.disableStorage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_debug {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.debug", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_homestead_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.homesteadBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_dao_fork_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.daoForkBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_dao_fork_support {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.daoForkSupport", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_eip150_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.eip150Block", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_eip150_hash {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.eip150Hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_eip155_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.eip155Block", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_eip158_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.eip158Block", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_byzantium_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.byzantiumBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_constantinople_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.constantinopleBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_petersburg_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.petersburgBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_istanbul_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.istanbulBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_muir_glacier_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.muirGlacierBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_berlin_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.berlinBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_london_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.londonBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_arrow_glacier_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.arrowGlacierBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_gray_glacier_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.grayGlacierBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_merge_netsplit_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.mergeNetsplitBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_shanghai_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.shanghaiBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_overrides_period_cancun_block {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.overrides.cancunBlock", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_enable_memory {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.enableMemory", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_enable_return_data {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.enableReturnData", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trace_config_period_tracer_json_config {
        local_var_req_builder = local_var_req_builder.query(&[("traceConfig.tracerJsonConfig", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_number {
        local_var_req_builder = local_var_req_builder.query(&[("blockNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_hash {
        local_var_req_builder = local_var_req_builder.query(&[("blockHash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = block_time {
        local_var_req_builder = local_var_req_builder.query(&[("blockTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proposer_address {
        local_var_req_builder = local_var_req_builder.query(&[("proposerAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = chain_id {
        local_var_req_builder = local_var_req_builder.query(&[("chainId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TraceTxError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn unbonding_delegation(configuration: &configuration::Configuration, validator_addr: &str, delegator_addr: &str) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryUnbondingDelegationResponse, Error<UnbondingDelegationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations/{delegatorAddr}/unbonding_delegation", local_var_configuration.base_path, validatorAddr=crate::apis::urlencode(validator_addr), delegatorAddr=crate::apis::urlencode(delegator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UnbondingDelegationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn upgraded_consensus_state(configuration: &configuration::Configuration, last_height: &str) -> Result<crate::models::CosmosPeriodUpgradePeriodV1beta1PeriodQueryUpgradedConsensusStateResponse, Error<UpgradedConsensusStateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/upgrade/v1beta1/upgraded_consensus_state/{lastHeight}", local_var_configuration.base_path, lastHeight=crate::apis::urlencode(last_height));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpgradedConsensusStateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator(configuration: &configuration::Configuration, validator_addr: &str) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryValidatorResponse, Error<ValidatorError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validatorAddr}", local_var_configuration.base_path, validatorAddr=crate::apis::urlencode(validator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidatorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_account(configuration: &configuration::Configuration, cons_address: &str) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodQueryValidatorAccountResponse, Error<ValidatorAccountError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/validator_account/{consAddress}", local_var_configuration.base_path, consAddress=crate::apis::urlencode(cons_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidatorAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_commission(configuration: &configuration::Configuration, validator_address: &str) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryValidatorCommissionResponse, Error<ValidatorCommissionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/validators/{validatorAddress}/commission", local_var_configuration.base_path, validatorAddress=crate::apis::urlencode(validator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidatorCommissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_delegations(configuration: &configuration::Configuration, validator_addr: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryValidatorDelegationsResponse, Error<ValidatorDelegationsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations", local_var_configuration.base_path, validatorAddr=crate::apis::urlencode(validator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidatorDelegationsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_distribution_info(configuration: &configuration::Configuration, validator_address: &str) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryValidatorDistributionInfoResponse, Error<ValidatorDistributionInfoError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/validators/{validatorAddress}", local_var_configuration.base_path, validatorAddress=crate::apis::urlencode(validator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidatorDistributionInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_outstanding_rewards(configuration: &configuration::Configuration, validator_address: &str) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryValidatorOutstandingRewardsResponse, Error<ValidatorOutstandingRewardsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/validators/{validatorAddress}/outstanding_rewards", local_var_configuration.base_path, validatorAddress=crate::apis::urlencode(validator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidatorOutstandingRewardsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_slashes(configuration: &configuration::Configuration, validator_address: &str, starting_height: Option<&str>, ending_height: Option<&str>, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodDistributionPeriodV1beta1PeriodQueryValidatorSlashesResponse, Error<ValidatorSlashesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/distribution/v1beta1/validators/{validatorAddress}/slashes", local_var_configuration.base_path, validatorAddress=crate::apis::urlencode(validator_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = starting_height {
        local_var_req_builder = local_var_req_builder.query(&[("startingHeight", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ending_height {
        local_var_req_builder = local_var_req_builder.query(&[("endingHeight", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidatorSlashesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validator_unbonding_delegations(configuration: &configuration::Configuration, validator_addr: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryValidatorUnbondingDelegationsResponse, Error<ValidatorUnbondingDelegationsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators/{validatorAddr}/unbonding_delegations", local_var_configuration.base_path, validatorAddr=crate::apis::urlencode(validator_addr));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidatorUnbondingDelegationsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn validators(configuration: &configuration::Configuration, status: Option<&str>, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodStakingPeriodV1beta1PeriodQueryValidatorsResponse, Error<ValidatorsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/staking/v1beta1/validators", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ValidatorsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn vote(configuration: &configuration::Configuration, proposal_id: &str, voter: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1PeriodQueryVoteResponse, Error<VoteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1/proposals/{proposalId}/votes/{voter}", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id), voter=crate::apis::urlencode(voter));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VoteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn vote_0(configuration: &configuration::Configuration, proposal_id: &str, voter: &str) -> Result<crate::models::CosmosPeriodGovPeriodV1beta1PeriodQueryVoteResponse, Error<Vote0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposalId}/votes/{voter}", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id), voter=crate::apis::urlencode(voter));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Vote0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn vote_by_proposal_voter(configuration: &configuration::Configuration, proposal_id: &str, voter: &str) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryVoteByProposalVoterResponse, Error<VoteByProposalVoterError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/vote_by_proposal_voter/{proposalId}/{voter}", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id), voter=crate::apis::urlencode(voter));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VoteByProposalVoterError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn votes(configuration: &configuration::Configuration, proposal_id: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGovPeriodV1PeriodQueryVotesResponse, Error<VotesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1/proposals/{proposalId}/votes", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn votes_0(configuration: &configuration::Configuration, proposal_id: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGovPeriodV1beta1PeriodQueryVotesResponse, Error<Votes0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/gov/v1beta1/proposals/{proposalId}/votes", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<Votes0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn votes_by_proposal(configuration: &configuration::Configuration, proposal_id: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryVotesByProposalResponse, Error<VotesByProposalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/votes_by_proposal/{proposalId}", local_var_configuration.base_path, proposalId=crate::apis::urlencode(proposal_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesByProposalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn votes_by_voter(configuration: &configuration::Configuration, voter: &str, pagination_period_key: Option<String>, pagination_period_offset: Option<&str>, pagination_period_limit: Option<&str>, pagination_period_count_total: Option<bool>, pagination_period_reverse: Option<bool>) -> Result<crate::models::CosmosPeriodGroupPeriodV1PeriodQueryVotesByVoterResponse, Error<VotesByVoterError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/cosmos/group/v1/votes_by_voter/{voter}", local_var_configuration.base_path, voter=crate::apis::urlencode(voter));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pagination_period_key {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_offset {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_limit {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_count_total {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.countTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pagination_period_reverse {
        local_var_req_builder = local_var_req_builder.query(&[("pagination.reverse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesByVoterError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

