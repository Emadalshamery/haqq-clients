/*
 * cosmos/app/v1alpha1/module.proto
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`clawback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClawbackError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`convert_coin`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConvertCoinError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`convert_erc20`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConvertErc20Error {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`convert_into_vesting_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConvertIntoVestingAccountError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`convert_vesting_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConvertVestingAccountError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_clawback_vesting_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateClawbackVestingAccountError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ethereum_tx`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EthereumTxError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_vesting_funder`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVestingFunderError {
    DefaultResponse(crate::models::GooglePeriodRpcPeriodStatus),
    UnknownValue(serde_json::Value),
}


pub async fn clawback(configuration: &configuration::Configuration, funder_address: Option<&str>, account_address: Option<&str>, dest_address: Option<&str>) -> Result<serde_json::Value, Error<ClawbackError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqq/vesting/v1/tx/clawback", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = funder_address {
        local_var_req_builder = local_var_req_builder.query(&[("funderAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_address {
        local_var_req_builder = local_var_req_builder.query(&[("accountAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dest_address {
        local_var_req_builder = local_var_req_builder.query(&[("destAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ClawbackError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn convert_coin(configuration: &configuration::Configuration, coin_period_denom: Option<&str>, coin_period_amount: Option<&str>, receiver: Option<&str>, sender: Option<&str>) -> Result<serde_json::Value, Error<ConvertCoinError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/erc20/v1/tx/convert_coin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin_period_denom {
        local_var_req_builder = local_var_req_builder.query(&[("coin.denom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = coin_period_amount {
        local_var_req_builder = local_var_req_builder.query(&[("coin.amount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = receiver {
        local_var_req_builder = local_var_req_builder.query(&[("receiver", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sender {
        local_var_req_builder = local_var_req_builder.query(&[("sender", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConvertCoinError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn convert_erc20(configuration: &configuration::Configuration, contract_address: Option<&str>, amount: Option<&str>, receiver: Option<&str>, sender: Option<&str>) -> Result<serde_json::Value, Error<ConvertErc20Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/erc20/v1/tx/convert_erc20", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = contract_address {
        local_var_req_builder = local_var_req_builder.query(&[("contractAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = amount {
        local_var_req_builder = local_var_req_builder.query(&[("amount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = receiver {
        local_var_req_builder = local_var_req_builder.query(&[("receiver", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sender {
        local_var_req_builder = local_var_req_builder.query(&[("sender", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConvertErc20Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn convert_into_vesting_account(configuration: &configuration::Configuration, from_address: Option<&str>, to_address: Option<&str>, start_time: Option<String>, merge: Option<bool>, stake: Option<bool>, validator_address: Option<&str>) -> Result<serde_json::Value, Error<ConvertIntoVestingAccountError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqq/vesting/v1/tx/convert_into_vesting_account", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = from_address {
        local_var_req_builder = local_var_req_builder.query(&[("fromAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to_address {
        local_var_req_builder = local_var_req_builder.query(&[("toAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_time {
        local_var_req_builder = local_var_req_builder.query(&[("startTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = merge {
        local_var_req_builder = local_var_req_builder.query(&[("merge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stake {
        local_var_req_builder = local_var_req_builder.query(&[("stake", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = validator_address {
        local_var_req_builder = local_var_req_builder.query(&[("validatorAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConvertIntoVestingAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn convert_vesting_account(configuration: &configuration::Configuration, vesting_address: Option<&str>) -> Result<serde_json::Value, Error<ConvertVestingAccountError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqq/vesting/v1/tx/convert_vesting_account", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = vesting_address {
        local_var_req_builder = local_var_req_builder.query(&[("vestingAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConvertVestingAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_clawback_vesting_account(configuration: &configuration::Configuration, from_address: Option<&str>, to_address: Option<&str>, start_time: Option<String>, merge: Option<bool>) -> Result<serde_json::Value, Error<CreateClawbackVestingAccountError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqq/vesting/v1/tx/create_clawback_vesting_account", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = from_address {
        local_var_req_builder = local_var_req_builder.query(&[("fromAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to_address {
        local_var_req_builder = local_var_req_builder.query(&[("toAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_time {
        local_var_req_builder = local_var_req_builder.query(&[("startTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = merge {
        local_var_req_builder = local_var_req_builder.query(&[("merge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateClawbackVestingAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn ethereum_tx(configuration: &configuration::Configuration, data_period_type_url: Option<&str>, data_period_value: Option<String>, size: Option<f64>, hash: Option<&str>, from: Option<&str>) -> Result<crate::models::EthermintPeriodEvmPeriodV1PeriodMsgEthereumTxResponse, Error<EthereumTxError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/evmos/evm/v1/ethereum_tx", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = data_period_type_url {
        local_var_req_builder = local_var_req_builder.query(&[("data.typeUrl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = data_period_value {
        local_var_req_builder = local_var_req_builder.query(&[("data.value", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = size {
        local_var_req_builder = local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = hash {
        local_var_req_builder = local_var_req_builder.query(&[("hash", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EthereumTxError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_vesting_funder(configuration: &configuration::Configuration, funder_address: Option<&str>, new_funder_address: Option<&str>, vesting_address: Option<&str>) -> Result<serde_json::Value, Error<UpdateVestingFunderError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/haqq/vesting/v1/tx/update_vesting_funder", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = funder_address {
        local_var_req_builder = local_var_req_builder.query(&[("funderAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_funder_address {
        local_var_req_builder = local_var_req_builder.query(&[("newFunderAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = vesting_address {
        local_var_req_builder = local_var_req_builder.query(&[("vestingAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateVestingFunderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

